/* USER CODE BEGIN PD */
#define DEBOUNCE_DELAY_MS 50  // Debounce delay in milliseconds
/* USER CODE END PD */

/* USER CODE BEGIN PV */
volatile uint8_t counter = 0;  // 3-bit counter
volatile uint32_t last_interrupt_time = 0;  // Last interrupt time in milliseconds
/* USER CODE END PV */

/* USER CODE BEGIN 0 */
void increment_counter(void) {
    counter = (counter + 1) % 8;  // Increment counter and wrap around using modulo
    // Set LED states based on counter value
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, (counter & 0x01) ? GPIO_PIN_SET : GPIO_PIN_RESET);  // LD1 (LSB)
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, (counter & 0x02) ? GPIO_PIN_SET : GPIO_PIN_RESET);  // LD2
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, (counter & 0x04) ? GPIO_PIN_SET : GPIO_PIN_RESET); // LD3 (MSB)
}
/* USER CODE END 0 */

int main(void) {
    // Infinite loop
    while (1) {
        // No additional logic needed in the main loop, everything is handled in interrupts
    }
}

/* USER CODE BEGIN 4 */
// External interrupt handler
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    if(GPIO_Pin == GPIO_PIN_13  ) {
          uint32_t current_time = HAL_GetTick();
          if ((current_time - last_interrupt_time) > DEBOUNCE_DELAY_MS) {
              last_interrupt_time = current_time;  // Update last interrupt time
              increment_counter();  // Update LED states based on counter value
          }
    }
}
/* USER CODE END 4 */
